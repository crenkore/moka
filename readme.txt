1. 自己构造的测试用例。要求描述每个测试用例的目的，以及预期结果（手动测试 即可，无需做自动化测试）
ls *.js | xargs1 -n [number] -P [number] wc -l //全功能正常测试
echo {0..8} | xargs1 -n [number] echo //测试题的范例
xargs1 //测试"边读取边处理"的逻辑
xargs1 wc -l //测试"边读取边处理"的逻辑2
echo {0..8} | xargs1 -n [非数字] //异常处理情况之一:参数不合法
echo {0..8} | xargs1 dd //异常处理情况之一:命令执行不正确
echo {0..8} | xargs1 notExistCmd //异常处理情况之一:命令不存在

2. 完成任务所花费时间
共4小时
我的工作方法是:先建立整体认识,就是先使用了下xargs,man一下,然后大概有个印象,之后直接开始编程,在编程过程中宏观的思考下大体需要的东西,
然后到基础部分能执行(node进程\子进程使用等),这步大概花费1小时
后面到总体框架基本完成花费1h
后面是优化及各种测试时发现的未完成及缺陷的部分,不明白的边查资料边解决等,花费了剩余的时间

3. 已知bug或可以进一步优化的地方
已知bug:
a. -P num>1时的功能未真正实现,Node.js是单线程异步,未真正达到多线程效果.也就是说,是并发但没有并行,当数字大于1时,输出序列虽然非顺序输出,但次序始终确定
b. 也不算bug吧,就是我执行"echo {0..8} | xargs1 [-P 1] aa"(中括号表示可选)这个的时候会提示"/bin/sh: aa: command not found",
而不是和xargs一样提示"xargs: aa: No such file or directory".但-P大于1我做了处理是和xargs提示相同的
可进一步优化的地方:
单纯从代码上说的话,我觉得,可能再看下能不能继续抽出一些方法什么的,让人更能一看就明白吧,但我觉得似乎这个必要性已经不太大了.
另外,我觉得始终应该根据业务场景,现在没有业务场景的话,所以我只能说假设一些业务场景,比如,如果考虑此程序要被各种地方使用的话,那么应该增强封装性,
另外,如果后期有可以预计到的变化如增加新的参数等,应该预留一些容易修改的地方或者钩子什么的(参考设计模式的一些原则)